<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>‚öîÔ∏è Heroes Adventure - –°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∞—è RPG</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .game-interface {
        display: flex;
        height: 100vh;
      }

      .map-container {
        flex: 1;
        position: relative;
        background: #0f1419;
        overflow: hidden;
      }

      canvas {
        border: 2px solid #34495e;
        display: block;
        cursor: crosshair;
      }

      .ui-panel {
        width: 300px;
        background: rgba(52, 73, 94, 0.95);
        color: #ecf0f1;
        padding: 20px;
        backdrop-filter: blur(10px);
        border-left: 2px solid #3498db;
        overflow-y: auto;
      }

      .hero-info {
        background: rgba(41, 128, 185, 0.2);
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
        border: 1px solid #3498db;
      }

      .hero-avatar {
        width: 60px;
        height: 60px;
        background: linear-gradient(45deg, #e74c3c, #c0392b);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        margin-bottom: 10px;
      }

      .hero-name {
        font-size: 1.2rem;
        font-weight: bold;
        margin-bottom: 5px;
      }

      .hero-level {
        color: #f39c12;
        font-weight: bold;
      }

      .resources {
        background: rgba(39, 174, 96, 0.2);
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
        border: 1px solid #27ae60;
      }

      .resource-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
      }

      .quests {
        background: rgba(142, 68, 173, 0.2);
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
        border: 1px solid #8e44ad;
      }

      .quest-item {
        background: rgba(0, 0, 0, 0.3);
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 8px;
        border-left: 3px solid #9b59b6;
      }

      .quest-title {
        font-weight: bold;
        color: #e8daef;
      }

      .quest-description {
        font-size: 0.9rem;
        color: #bdc3c7;
        margin-top: 5px;
      }

      .quest-reward {
        color: #f1c40f;
        font-size: 0.8rem;
        margin-top: 5px;
      }

      .minimap {
        width: 200px;
        height: 150px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #34495e;
        border-radius: 5px;
        margin-bottom: 20px;
        position: relative;
      }

      .controls {
        background: rgba(0, 0, 0, 0.3);
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
      }

      .controls h3 {
        margin-bottom: 10px;
        color: #3498db;
      }

      .control-item {
        margin-bottom: 5px;
        font-size: 0.9rem;
      }

      .back-button {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(52, 73, 94, 0.9);
        color: #ecf0f1;
        border: 1px solid #3498db;
        padding: 10px 20px;
        border-radius: 20px;
        font-weight: bold;
        cursor: pointer;
        text-decoration: none;
        transition: all 0.3s ease;
        z-index: 100;
      }

      .back-button:hover {
        background: rgba(52, 152, 219, 0.9);
        transform: scale(1.05);
      }

      .notification {
        position: absolute;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(39, 174, 96, 0.9);
        color: white;
        padding: 15px 25px;
        border-radius: 10px;
        font-weight: bold;
        z-index: 200;
        display: none;
        animation: slideInOut 3s ease-in-out forwards;
      }

      .dialog {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(44, 62, 80, 0.95);
        color: #ecf0f1;
        padding: 30px;
        border-radius: 15px;
        border: 2px solid #3498db;
        max-width: 500px;
        text-align: center;
        display: none;
        z-index: 300;
        backdrop-filter: blur(10px);
      }

      .dialog h3 {
        color: #3498db;
        margin-bottom: 15px;
      }

      .dialog-buttons {
        margin-top: 20px;
        display: flex;
        gap: 10px;
        justify-content: center;
      }

      .btn {
        background: linear-gradient(45deg, #3498db, #2980b9);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s ease;
      }

      .btn:hover {
        background: linear-gradient(45deg, #2980b9, #21618c);
        transform: translateY(-2px);
      }

      .btn.decline {
        background: linear-gradient(45deg, #e74c3c, #c0392b);
      }

      .btn.decline:hover {
        background: linear-gradient(45deg, #c0392b, #a93226);
      }

      .action-points {
        background: rgba(230, 126, 34, 0.2);
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 10px;
        border: 1px solid #e67e22;
        text-align: center;
      }

      .fog-overlay {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        pointer-events: none;
      }

      @keyframes slideInOut {
        0% {
          transform: translate(-50%, -20px);
          opacity: 0;
        }
        20% {
          transform: translate(-50%, 0);
          opacity: 1;
        }
        80% {
          transform: translate(-50%, 0);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -20px);
          opacity: 0;
        }
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      .resource-node {
        animation: pulse 2s ease-in-out infinite;
      }

      .section-title {
        color: #3498db;
        font-weight: bold;
        margin-bottom: 10px;
        border-bottom: 1px solid #34495e;
        padding-bottom: 5px;
      }

      .shop-panel {
        background: rgba(231, 76, 60, 0.2);
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
        border: 1px solid #e74c3c;
      }

      .shop-tabs {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-bottom: 15px;
      }

      .shop-tab {
        background: rgba(0, 0, 0, 0.3);
        color: #bdc3c7;
        border: 1px solid #34495e;
        padding: 8px 12px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 0.8rem;
        transition: all 0.3s ease;
      }

      .shop-tab.active {
        background: #e74c3c;
        color: white;
        border-color: #c0392b;
      }

      .shop-tab:hover {
        background: #c0392b;
        color: white;
      }

      .shop-item {
        background: rgba(0, 0, 0, 0.4);
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 8px;
        border-left: 3px solid #e67e22;
      }

      .shop-item-name {
        font-weight: bold;
        color: #f39c12;
        margin-bottom: 5px;
      }

      .shop-item-description {
        font-size: 0.85rem;
        color: #bdc3c7;
        margin-bottom: 8px;
      }

      .shop-item-cost {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .cost-display {
        font-size: 0.8rem;
        color: #f1c40f;
      }

      .shop-buy-btn {
        background: linear-gradient(45deg, #27ae60, #229954);
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 0.8rem;
        transition: all 0.3s ease;
      }

      .shop-buy-btn:hover {
        background: linear-gradient(45deg, #229954, #1e8449);
        transform: translateY(-1px);
      }

      .shop-buy-btn:disabled {
        background: #7f8c8d;
        cursor: not-allowed;
        transform: none;
      }

      .army-info {
        background: rgba(52, 152, 219, 0.2);
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 15px;
        border: 1px solid #3498db;
      }

      .army-unit {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
      }

      .hero-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 10px;
      }

      .stat-item {
        background: rgba(0, 0, 0, 0.3);
        padding: 8px;
        border-radius: 5px;
        text-align: center;
      }

      .stat-value {
        font-size: 1.2rem;
        font-weight: bold;
        color: #f39c12;
      }

      .stat-name {
        font-size: 0.8rem;
        color: #bdc3c7;
      }

      .loading-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
        color: #ecf0f1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .loading-title {
        font-size: 3rem;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .loading-progress {
        width: 300px;
        height: 20px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 20px;
      }

      .loading-bar {
        height: 100%;
        background: linear-gradient(45deg, #3498db, #2980b9);
        width: 0%;
        border-radius: 10px;
        transition: width 0.5s ease;
      }

      .loading-text {
        font-size: 1.2rem;
        color: #bdc3c7;
      }

      @media (max-width: 768px) {
        .game-interface {
          flex-direction: column;
        }

        .map-container {
          height: 60vh;
        }

        .ui-panel {
          width: 100%;
          max-height: 40vh;
          border-left: none;
          border-top: 2px solid #3498db;
        }

        canvas {
          width: 100%;
          height: 100%;
        }
      }
    </style>
  </head>
  <body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
      <div class="loading-title">‚öîÔ∏è Heroes Adventure</div>
      <div class="loading-progress">
        <div class="loading-bar" id="loadingBar"></div>
      </div>
      <div class="loading-text" id="loadingText">Generating world...</div>
    </div>

    <a href="../index.html" class="back-button">‚Üê –ö —É—Ä–æ–∫–∞–º</a>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <!-- Dialog -->
    <div class="dialog" id="dialog">
      <h3 id="dialogTitle">Title</h3>
      <p id="dialogText">Text</p>
      <div class="dialog-buttons">
        <button class="btn" id="dialogAccept">–ü—Ä–∏–Ω—è—Ç—å</button>
        <button class="btn decline" id="dialogDecline">–û—Ç–∫–ª–æ–Ω–∏—Ç—å</button>
      </div>
    </div>

    <!-- Game Interface -->
    <div class="game-interface" id="gameInterface" style="display: none">
      <!-- Map Container -->
      <div class="map-container">
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
      </div>

      <!-- UI Panel -->
      <div class="ui-panel">
        <!-- Hero Information -->
        <div class="hero-info">
          <div class="section-title">‚öîÔ∏è –ì–µ—Ä–æ–π</div>
          <div class="hero-avatar" id="heroAvatar">üõ°Ô∏è</div>
          <div class="hero-name" id="heroName">–°—ç—Ä –ö–æ–¥–µ—Ä—É—Å</div>
          <div class="hero-level" id="heroLevel">–£—Ä–æ–≤–µ–Ω—å 1</div>

          <div class="hero-stats">
            <div class="stat-item">
              <div class="stat-value" id="heroAttack">10</div>
              <div class="stat-name">–ê—Ç–∞–∫–∞</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="heroDefense">8</div>
              <div class="stat-name">–ó–∞—â–∏—Ç–∞</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="heroMagic">5</div>
              <div class="stat-name">–ú–∞–≥–∏—è</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="heroKnowledge">12</div>
              <div class="stat-name">–ó–Ω–∞–Ω–∏—è</div>
            </div>
          </div>
        </div>

        <!-- Action Points -->
        <div class="action-points">
          <div class="section-title">üèÉ‚Äç‚ôÇÔ∏è –î–µ–π—Å—Ç–≤–∏—è</div>
          <div>–û—á–∫–∏ –¥–≤–∏–∂–µ–Ω–∏—è: <span id="actionPoints">100/100</span></div>
        </div>

        <!-- Resources -->
        <div class="resources">
          <div class="section-title">üí∞ –†–µ—Å—É—Ä—Å—ã</div>
          <div class="resource-item">
            <span>üí∞ –ó–æ–ª–æ—Ç–æ:</span>
            <span id="gold">1000</span>
          </div>
          <div class="resource-item">
            <span>ü™® –ö–∞–º–µ–Ω—å:</span>
            <span id="stone">10</span>
          </div>
          <div class="resource-item">
            <span>üå≥ –î–µ—Ä–µ–≤–æ:</span>
            <span id="wood">15</span>
          </div>
          <div class="resource-item">
            <span>‚ö° –ö—Ä–∏—Å—Ç–∞–ª–ª—ã:</span>
            <span id="crystals">5</span>
          </div>
        </div>

        <!-- Shop/Building System -->
        <div class="shop-panel">
          <div class="section-title">üè™ –ú–∞–≥–∞–∑–∏–Ω</div>
          <div class="shop-tabs">
            <button
              class="shop-tab active"
              onclick="switchShopTab('buildings')"
            >
              üèóÔ∏è –ü–æ—Å—Ç—Ä–æ–π–∫–∏
            </button>
            <button class="shop-tab" onclick="switchShopTab('equipment')">
              ‚öîÔ∏è –°–Ω–∞—Ä—è–∂–µ–Ω–∏–µ
            </button>
            <button class="shop-tab" onclick="switchShopTab('magic')">
              üîÆ –ú–∞–≥–∏—è
            </button>
            <button class="shop-tab" onclick="switchShopTab('army')">
              üõ°Ô∏è –ê—Ä–º–∏—è
            </button>
          </div>

          <div id="shopContent">
            <!-- –ö–æ–Ω—Ç–µ–Ω—Ç –º–∞–≥–∞–∑–∏–Ω–∞ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª—è—Ç—å—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
          </div>
        </div>

        <!-- Quests -->
        <div class="quests">
          <div class="section-title">üìã –ó–∞–¥–∞–Ω–∏—è</div>
          <div id="questsList">
            <div class="quest-item">
              <div class="quest-title">–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å</div>
              <div class="quest-description">
                –û—Ç–∫—Ä–æ–π—Ç–µ 5 –Ω–æ–≤—ã—Ö –æ–±–ª–∞—Å—Ç–µ–π –∫–∞—Ä—Ç—ã
              </div>
              <div class="quest-reward">–ù–∞–≥—Ä–∞–¥–∞: 500 –∑–æ–ª–æ—Ç–∞</div>
            </div>
            <div class="quest-item">
              <div class="quest-title">–°–±–æ—Ä—â–∏–∫ —Å–æ–∫—Ä–æ–≤–∏—â</div>
              <div class="quest-description">
                –ù–∞–π–¥–∏—Ç–µ 3 —Å—É–Ω–¥—É–∫–∞ —Å —Å–æ–∫—Ä–æ–≤–∏—â–∞–º–∏
              </div>
              <div class="quest-reward">–ù–∞–≥—Ä–∞–¥–∞: –ú–∞–≥–∏—á–µ—Å–∫–∏–π –∞—Ä—Ç–µ—Ñ–∞–∫—Ç</div>
            </div>
          </div>
        </div>

        <!-- Minimap -->
        <div class="minimap" id="minimap">
          <div class="section-title">üó∫Ô∏è –ú–∏–Ω–∏-–∫–∞—Ä—Ç–∞</div>
        </div>

        <!-- Controls -->
        <div class="controls">
          <div class="section-title">üéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</div>
          <div class="control-item">üñ±Ô∏è –õ–ö–ú - –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≥–µ—Ä–æ—è</div>
          <div class="control-item">üñ±Ô∏è –ü–ö–ú - –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–∞–π–ª–µ</div>
          <div class="control-item">‚å®Ô∏è –ü—Ä–æ–±–µ–ª - –°–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥</div>
          <div class="control-item">‚å®Ô∏è M - –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ç—É–º–∞–Ω –≤–æ–π–Ω—ã</div>
          <div class="control-item">‚å®Ô∏è Q - –°–ø–∏—Å–æ–∫ –∫–≤–µ—Å—Ç–æ–≤</div>
          <div class="control-item">‚å®Ô∏è S - –û—Ç–∫—Ä—ã—Ç—å/–∑–∞–∫—Ä—ã—Ç—å –º–∞–≥–∞–∑–∏–Ω</div>
          <div
            class="control-item"
            style="
              color: #f1c40f;
              font-size: 0.8rem;
              margin-top: 8px;
              border-top: 1px solid #34495e;
              padding-top: 8px;
            "
          >
            üí° –í –º–∞–≥–∞–∑–∏–Ω–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å —Ç–æ–≤–∞—Ä–æ–≤:<br />
            üü¢ –ó–µ–ª–µ–Ω—ã–π = —Ö–≤–∞—Ç–∞–µ—Ç —Ä–µ—Å—É—Ä—Å–æ–≤<br />
            üî¥ –ö—Ä–∞—Å–Ω—ã–π = –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç —Ä–µ—Å—É—Ä—Å–æ–≤
          </div>
        </div>
      </div>
    </div>

    <script>
      // ===========================================
      // –ö–û–ù–°–¢–ê–ù–¢–´ –ò –ù–ê–°–¢–†–û–ô–ö–ò –ò–ì–†–´
      // ===========================================

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      const TILE_SIZE = 40;
      const MAP_WIDTH = 30;
      const MAP_HEIGHT = 25;
      const VIEWPORT_TILES_X = Math.floor(canvas.width / TILE_SIZE);
      const VIEWPORT_TILES_Y = Math.floor(canvas.height / TILE_SIZE);

      // –¢–∏–ø—ã —Ç–∞–π–ª–æ–≤
      const TILE_TYPES = {
        GRASS: { color: "#4CAF50", passable: true, cost: 1, emoji: "üåø" },
        FOREST: { color: "#2E7D32", passable: true, cost: 2, emoji: "üå≤" },
        MOUNTAIN: { color: "#795548", passable: false, cost: 999, emoji: "‚õ∞Ô∏è" },
        WATER: { color: "#2196F3", passable: false, cost: 999, emoji: "üåä" },
        ROAD: { color: "#FFC107", passable: true, cost: 0.5, emoji: "üõ§Ô∏è" },
        TOWN: { color: "#9C27B0", passable: true, cost: 1, emoji: "üè∞" },
        TREASURE: { color: "#FF9800", passable: true, cost: 1, emoji: "üí∞" },
        MONSTER: { color: "#F44336", passable: true, cost: 1, emoji: "üëπ" },
        RESOURCE_GOLD: {
          color: "#FFD700",
          passable: true,
          cost: 1,
          emoji: "üíé",
        },
        RESOURCE_STONE: {
          color: "#78909C",
          passable: true,
          cost: 1,
          emoji: "ü™®",
        },
        RESOURCE_WOOD: {
          color: "#8D6E63",
          passable: true,
          cost: 1,
          emoji: "üå≥",
        },
        BUILDING: { color: "#8E44AD", passable: true, cost: 1, emoji: "üèóÔ∏è" },
      };

      // ===========================================
      // –ò–ì–†–û–í–û–ï –°–û–°–¢–û–Ø–ù–ò–ï
      // ===========================================

      let gameState = {
        hero: {
          x: 5,
          y: 5,
          level: 1,
          experience: 0,
          actionPoints: 100,
          maxActionPoints: 100,
          stats: {
            attack: 10,
            defense: 8,
            magic: 5,
            knowledge: 12,
          },
          equipment: {
            weapon: null,
            armor: null,
            accessory: null,
          },
        },
        resources: {
          gold: 1000,
          stone: 10,
          wood: 15,
          crystals: 5,
        },
        army: {
          warriors: 0,
          archers: 0,
          mages: 0,
        },
        buildings: [],
        currentShopTab: "buildings",
        camera: {
          x: 0,
          y: 0,
        },
        turnNumber: 1,
        questsCompleted: 0,
        treasuresFound: 0,
        areasExplored: 1,
        showFogOfWar: true,
      };

      let gameMap = [];
      let fogOfWar = [];
      let exploredTiles = new Set();
      let quests = [];
      let pathToTarget = [];
      let selectedTarget = null;

      // ===========================================
      // –ì–ï–ù–ï–†–ê–¶–ò–Ø –ö–ê–†–¢–´
      // ===========================================

      function generateMap() {
        let attempts = 0;
        const maxAttempts = 10;

        do {
          attempts++;
          gameMap = [];
          fogOfWar = [];

          // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã —Ç—Ä–∞–≤–æ–π
          for (let y = 0; y < MAP_HEIGHT; y++) {
            gameMap[y] = [];
            fogOfWar[y] = [];
            for (let x = 0; x < MAP_WIDTH; x++) {
              gameMap[y][x] = "GRASS";
              fogOfWar[y][x] = true;
            }
          }

          generateBasicMap();

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–≤—è–∑–Ω–æ—Å—Ç—å –∏ –∏—Å–ø—Ä–∞–≤–ª—è–µ–º –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
          if (!isMapConnected()) {
            fixMapConnectivity();
          }
        } while (!isMapConnected() && attempts < maxAttempts);

        if (attempts >= maxAttempts) {
          console.warn(
            "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å–≤—è–∑–Ω—É—é –∫–∞—Ä—Ç—É, –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é"
          );
          generateSimpleMap();
        }

        // –û—Ç–∫—Ä—ã–≤–∞–µ–º –æ–±–ª–∞—Å—Ç—å –≤–æ–∫—Ä—É–≥ –≥–µ—Ä–æ—è
        revealArea(gameState.hero.x, gameState.hero.y, 2);
      }

      function generateBasicMap() {
        // 1. –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é —Å–µ—Ç—å –¥–æ—Ä–æ–≥ (–≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º —Å–≤—è–∑–Ω–æ—Å—Ç—å)
        generateMainRoadNetwork();

        // 2. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ–∫ (—Å –º–æ—Å—Ç–∞–º–∏ –Ω–∞ –¥–æ—Ä–æ–≥–∞—Ö)
        generateRivers();

        // 3. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–µ—Å–æ–≤ (–∏–∑–±–µ–≥–∞—è –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø—É—Ç–µ–π)
        generateForests();

        // 4. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≥–æ—Ä (–∏–∑–±–µ–≥–∞—è –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø—É—Ç–µ–π)
        generateMountains();

        // 5. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–æ—Ä–æ–≥–∏
        generateAdditionalRoads();

        // 6. –†–∞–∑–º–µ—â–µ–Ω–∏–µ –≥–æ—Ä–æ–¥–æ–≤ –Ω–∞ –¥–æ—Ä–æ–≥–∞—Ö
        placeTowns();

        // 7. –†–∞–∑–º–µ—â–µ–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤ –∏ —Å–æ–∫—Ä–æ–≤–∏—â
        placeResources();

        // 8. –†–∞–∑–º–µ—â–µ–Ω–∏–µ –º–æ–Ω—Å—Ç—Ä–æ–≤
        placeMonsters();
      }

      function generateSimpleMap() {
        // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–ª—è –∞–≤–∞—Ä–∏–π–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤

        // –ì–ª–∞–≤–Ω–∞—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –¥–æ—Ä–æ–≥–∞
        const mainRoadY = Math.floor(MAP_HEIGHT / 2);
        for (let x = 0; x < MAP_WIDTH; x++) {
          gameMap[mainRoadY][x] = "ROAD";
        }

        // –ì–ª–∞–≤–Ω–∞—è –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –¥–æ—Ä–æ–≥–∞
        const mainRoadX = Math.floor(MAP_WIDTH / 2);
        for (let y = 0; y < MAP_HEIGHT; y++) {
          gameMap[y][mainRoadX] = "ROAD";
        }

        // –ü—Ä–æ—Å—Ç–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
        placeTowns();
        placeResources();
      }

      function generateMainRoadNetwork() {
        // –°–æ–∑–¥–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é –∫—Ä–µ—Å—Ç–æ–æ–±—Ä–∞–∑–Ω—É—é —Å–µ—Ç—å –¥–æ—Ä–æ–≥
        const centerX = Math.floor(MAP_WIDTH / 2);
        const centerY = Math.floor(MAP_HEIGHT / 2);

        // –ì–ª–∞–≤–Ω–∞—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –¥–æ—Ä–æ–≥–∞
        for (let x = 0; x < MAP_WIDTH; x++) {
          gameMap[centerY][x] = "ROAD";
          // –î–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –ø—É—Ç–∏ –¥–ª—è –∏–∑–±—ã—Ç–æ—á–Ω–æ—Å—Ç–∏
          if (centerY > 0) gameMap[centerY - 1][x] = "GRASS"; // —É–±–µ–∂–¥–∞–µ–º—Å—è —á—Ç–æ –µ—Å—Ç—å –ø—Ä–æ—Ö–æ–¥
          if (centerY < MAP_HEIGHT - 1) gameMap[centerY + 1][x] = "GRASS";
        }

        // –ì–ª–∞–≤–Ω–∞—è –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –¥–æ—Ä–æ–≥–∞
        for (let y = 0; y < MAP_HEIGHT; y++) {
          gameMap[y][centerX] = "ROAD";
          // –î–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –ø—É—Ç–∏
          if (centerX > 0) gameMap[y][centerX - 1] = "GRASS";
          if (centerX < MAP_WIDTH - 1) gameMap[y][centerX + 1] = "GRASS";
        }

        // –î–æ–±–∞–≤–ª—è–µ–º –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ –¥–æ—Ä–æ–≥–∏ –¥–ª—è –ª—É—á—à–µ–π —Å–≤—è–∑–Ω–æ—Å—Ç–∏
        for (let i = 0; i < Math.min(MAP_WIDTH, MAP_HEIGHT); i++) {
          if (i < MAP_WIDTH && i < MAP_HEIGHT) {
            gameMap[i][i] = "ROAD"; // –¥–∏–∞–≥–æ–Ω–∞–ª—å —Å–ª–µ–≤–∞-–Ω–∞–ø—Ä–∞–≤–æ
          }
          if (i < MAP_WIDTH && MAP_HEIGHT - 1 - i >= 0) {
            gameMap[MAP_HEIGHT - 1 - i][i] = "ROAD"; // –¥–∏–∞–≥–æ–Ω–∞–ª—å —Å–ø—Ä–∞–≤–∞-–Ω–∞–ª–µ–≤–æ
          }
        }

        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–æ–µ–¥–∏–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—É—Ç–∏ –ø–æ –ø–µ—Ä–∏–º–µ—Ç—Ä—É
        for (let x = 0; x < MAP_WIDTH; x += 5) {
          for (let y = 0; y < MAP_HEIGHT; y += 5) {
            gameMap[y][x] = "ROAD";
          }
        }
      }

      function generateRivers() {
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –Ω–µ–±–æ–ª—å—à–∏—Ö —Ä–µ–∫
        const numRivers = 2;

        for (let r = 0; r < numRivers; r++) {
          const riverStart = {
            x: 0,
            y: Math.floor(MAP_HEIGHT * (0.3 + r * 0.4)),
          };
          let current = { ...riverStart };

          while (current.x < MAP_WIDTH) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–µ–º –ª–∏ –º—ã –¥–æ—Ä–æ–≥—É (–æ—Å—Ç–∞–≤–ª—è–µ–º –º–æ—Å—Ç—ã)
            if (gameMap[current.y][current.x] !== "ROAD") {
              gameMap[current.y][current.x] = "WATER";
            }

            // –°–ª—É—á–∞–π–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–±–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–µ)
            const direction = Math.random();
            if (direction < 0.2 && current.y > 2) current.y--;
            else if (direction > 0.8 && current.y < MAP_HEIGHT - 3) current.y++;

            current.x++;
          }
        }
      }

      function generateForests() {
        for (let i = 0; i < 12; i++) {
          const centerX = Math.floor(Math.random() * MAP_WIDTH);
          const centerY = Math.floor(Math.random() * MAP_HEIGHT);
          const size = Math.floor(Math.random() * 4) + 2;

          for (let x = centerX - size; x <= centerX + size; x++) {
            for (let y = centerY - size; y <= centerY + size; y++) {
              if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
                const distance = Math.sqrt(
                  (x - centerX) ** 2 + (y - centerY) ** 2
                );
                // –ù–µ —Ä–∞–∑–º–µ—â–∞–µ–º –ª–µ—Å –Ω–∞ –¥–æ—Ä–æ–≥–∞—Ö –∏ —Ä—è–¥–æ–º —Å –Ω–∏–º–∏
                const nearRoad = isNearRoad(x, y, 1);
                if (
                  distance <= size &&
                  Math.random() < 0.6 &&
                  gameMap[y][x] === "GRASS" &&
                  !nearRoad
                ) {
                  gameMap[y][x] = "FOREST";
                }
              }
            }
          }
        }
      }

      function generateMountains() {
        for (let i = 0; i < 6; i++) {
          const centerX = Math.floor(Math.random() * MAP_WIDTH);
          const centerY = Math.floor(Math.random() * MAP_HEIGHT);
          const size = Math.floor(Math.random() * 3) + 1;

          // –ò–∑–±–µ–≥–∞–µ–º —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã—Ö –æ–±–ª–∞—Å—Ç–µ–π –∫–∞—Ä—Ç—ã
          const centerDistanceX = Math.abs(centerX - MAP_WIDTH / 2);
          const centerDistanceY = Math.abs(centerY - MAP_HEIGHT / 2);

          if (centerDistanceX < 3 && centerDistanceY < 3) continue;

          for (let x = centerX - size; x <= centerX + size; x++) {
            for (let y = centerY - size; y <= centerY + size; y++) {
              if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
                const distance = Math.sqrt(
                  (x - centerX) ** 2 + (y - centerY) ** 2
                );
                // –ù–µ —Ä–∞–∑–º–µ—â–∞–µ–º –≥–æ—Ä—ã –Ω–∞ –¥–æ—Ä–æ–≥–∞—Ö –∏ —Ä—è–¥–æ–º —Å –Ω–∏–º–∏
                const nearRoad = isNearRoad(x, y, 2);
                if (
                  distance <= size &&
                  Math.random() < 0.7 &&
                  !nearRoad &&
                  gameMap[y][x] === "GRASS"
                ) {
                  gameMap[y][x] = "MOUNTAIN";
                }
              }
            }
          }
        }
      }

      function generateAdditionalRoads() {
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–µ–±–æ–ª—å—à–∏–µ –¥–æ—Ä–æ–≥–∏ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —Å–≤—è–∑–Ω–æ—Å—Ç–∏
        const roadPoints = [
          { x: Math.floor(MAP_WIDTH * 0.2), y: Math.floor(MAP_HEIGHT * 0.3) },
          { x: Math.floor(MAP_WIDTH * 0.8), y: Math.floor(MAP_HEIGHT * 0.7) },
          { x: Math.floor(MAP_WIDTH * 0.3), y: Math.floor(MAP_HEIGHT * 0.8) },
          { x: Math.floor(MAP_WIDTH * 0.7), y: Math.floor(MAP_HEIGHT * 0.2) },
        ];

        roadPoints.forEach((point) => {
          // –°–æ–∑–¥–∞–µ–º –∫–æ—Ä–æ—Ç–∫–∏–µ –¥–æ—Ä–æ–≥–∏ –æ—Ç —ç—Ç–∏—Ö —Ç–æ—á–µ–∫ –∫ —Ü–µ–Ω—Ç—Ä—É
          const path = findPathIgnoringObstacles(
            point.x,
            point.y,
            Math.floor(MAP_WIDTH / 2),
            Math.floor(MAP_HEIGHT / 2)
          );

          path.forEach((p) => {
            if (gameMap[p.y][p.x] !== "WATER") {
              gameMap[p.y][p.x] = "ROAD";
            }
          });
        });
      }

      function isNearRoad(x, y, distance) {
        for (let dx = -distance; dx <= distance; dx++) {
          for (let dy = -distance; dy <= distance; dy++) {
            const checkX = x + dx;
            const checkY = y + dy;
            if (
              checkX >= 0 &&
              checkX < MAP_WIDTH &&
              checkY >= 0 &&
              checkY < MAP_HEIGHT
            ) {
              if (gameMap[checkY][checkX] === "ROAD") {
                return true;
              }
            }
          }
        }
        return false;
      }

      function isMapConnected() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–≤—è–∑–Ω–æ—Å—Ç—å —Å –ø–æ–º–æ—â—å—é flood fill
        const visited = Array(MAP_HEIGHT)
          .fill()
          .map(() => Array(MAP_WIDTH).fill(false));
        const queue = [{ x: gameState.hero.x, y: gameState.hero.y }];
        visited[gameState.hero.y][gameState.hero.x] = true;

        let reachableCount = 0;
        let totalPassable = 0;

        // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Ö–æ–¥–∏–º—ã—Ö —Ç–∞–π–ª–æ–≤
        for (let y = 0; y < MAP_HEIGHT; y++) {
          for (let x = 0; x < MAP_WIDTH; x++) {
            if (isPassable(x, y)) {
              totalPassable++;
            }
          }
        }

        // Flood fill –∏–∑ –ø–æ–∑–∏—Ü–∏–∏ –≥–µ—Ä–æ—è
        while (queue.length > 0) {
          const current = queue.shift();
          reachableCount++;

          const neighbors = getNeighbors(current.x, current.y);
          for (const neighbor of neighbors) {
            if (!visited[neighbor.y][neighbor.x]) {
              visited[neighbor.y][neighbor.x] = true;
              queue.push(neighbor);
            }
          }
        }

        // –°—á–∏—Ç–∞–µ–º –∫–∞—Ä—Ç—É —Å–≤—è–∑–Ω–æ–π, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ –º–∏–Ω–∏–º—É–º 80% –ø—Ä–æ—Ö–æ–¥–∏–º—ã—Ö —Ç–∞–π–ª–æ–≤
        const connectivity = reachableCount / totalPassable;
        console.log(
          `Map connectivity: ${(connectivity * 100).toFixed(
            1
          )}% (${reachableCount}/${totalPassable})`
        );
        return connectivity >= 0.8;
      }

      function fixMapConnectivity() {
        console.log("Fixing map connectivity...");

        // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–±–ª–∞—Å—Ç–∏
        const visited = Array(MAP_HEIGHT)
          .fill()
          .map(() => Array(MAP_WIDTH).fill(false));
        const mainArea = new Set();

        // –û—Ç–º–µ—á–∞–µ–º –≥–ª–∞–≤–Ω—É—é –æ–±–ª–∞—Å—Ç—å (–æ—Ç –ø–æ–∑–∏—Ü–∏–∏ –≥–µ—Ä–æ—è)
        const queue = [{ x: gameState.hero.x, y: gameState.hero.y }];
        visited[gameState.hero.y][gameState.hero.x] = true;

        while (queue.length > 0) {
          const current = queue.shift();
          mainArea.add(`${current.x},${current.y}`);

          const neighbors = getNeighbors(current.x, current.y);
          for (const neighbor of neighbors) {
            if (!visited[neighbor.y][neighbor.x]) {
              visited[neighbor.y][neighbor.x] = true;
              queue.push(neighbor);
            }
          }
        }

        // –ù–∞—Ö–æ–¥–∏–º –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–±–ª–∞—Å—Ç–∏ –∏ —Å–æ–µ–¥–∏–Ω—è–µ–º –∏—Ö
        for (let y = 0; y < MAP_HEIGHT; y++) {
          for (let x = 0; x < MAP_WIDTH; x++) {
            if (isPassable(x, y) && !visited[y][x]) {
              // –ù–∞–π–¥–µ–Ω–∞ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ–±–ª–∞—Å—Ç—å
              connectToMainArea(x, y, mainArea);
            }
          }
        }
      }

      function connectToMainArea(startX, startY, mainArea) {
        // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à—É—é —Ç–æ—á–∫—É –≥–ª–∞–≤–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏
        let closestPoint = null;
        let minDistance = Infinity;

        for (const pointStr of mainArea) {
          const [x, y] = pointStr.split(",").map(Number);
          const distance = Math.abs(x - startX) + Math.abs(y - startY);
          if (distance < minDistance) {
            minDistance = distance;
            closestPoint = { x, y };
          }
        }

        if (closestPoint) {
          // –°–æ–∑–¥–∞–µ–º –ø—Ä—è–º–æ–π –ø—É—Ç—å, —É–±–∏—Ä–∞—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
          createDirectPath(startX, startY, closestPoint.x, closestPoint.y);
        }
      }

      function createDirectPath(x1, y1, x2, y2) {
        // –ü—Ä–æ—Å—Ç–æ–π –∞–ª–≥–æ—Ä–∏—Ç–º –ë—Ä–µ–∑–µ–Ω—Ö–µ–º–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä—è–º–æ–≥–æ –ø—É—Ç–∏
        const dx = Math.abs(x2 - x1);
        const dy = Math.abs(y2 - y1);
        const sx = x1 < x2 ? 1 : -1;
        const sy = y1 < y2 ? 1 : -1;
        let err = dx - dy;

        let x = x1;
        let y = y1;

        while (true) {
          // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Ö–æ–¥ (—É–±–∏—Ä–∞–µ–º –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è)
          if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
            if (gameMap[y][x] === "MOUNTAIN" || gameMap[y][x] === "WATER") {
              gameMap[y][x] = "ROAD";
            }
          }

          if (x === x2 && y === y2) break;

          const e2 = 2 * err;
          if (e2 > -dy) {
            err -= dy;
            x += sx;
          }
          if (e2 < dx) {
            err += dx;
            y += sy;
          }
        }
      }

      function findPathIgnoringObstacles(x1, y1, x2, y2) {
        // –ü—Ä–æ—Å—Ç–æ–π –ø—É—Ç—å –ø–æ –ø—Ä—è–º–æ–π, –∏–≥–Ω–æ—Ä–∏—Ä—É—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
        const path = [];
        const dx = Math.abs(x2 - x1);
        const dy = Math.abs(y2 - y1);
        const sx = x1 < x2 ? 1 : -1;
        const sy = y1 < y2 ? 1 : -1;
        let err = dx - dy;

        let x = x1;
        let y = y1;

        while (true) {
          path.push({ x, y });
          if (x === x2 && y === y2) break;

          const e2 = 2 * err;
          if (e2 > -dy) {
            err -= dy;
            x += sx;
          }
          if (e2 < dx) {
            err += dx;
            y += sy;
          }
        }

        return path;
      }

      function placeTowns() {
        const townPositions = [
          { x: 8, y: 8 },
          { x: 22, y: 15 },
          { x: 15, y: 5 },
          { x: 5, y: 20 },
        ];

        townPositions.forEach((pos) => {
          if (pos.x < MAP_WIDTH && pos.y < MAP_HEIGHT) {
            gameMap[pos.y][pos.x] = "TOWN";
          }
        });
      }

      function placeResources() {
        // –†–∞–∑–º–µ—â–µ–Ω–∏–µ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
        const resourceTypes = [
          "RESOURCE_GOLD",
          "RESOURCE_STONE",
          "RESOURCE_WOOD",
          "TREASURE",
        ];

        for (let i = 0; i < 25; i++) {
          const x = Math.floor(Math.random() * MAP_WIDTH);
          const y = Math.floor(Math.random() * MAP_HEIGHT);

          if (gameMap[y][x] === "GRASS" || gameMap[y][x] === "FOREST") {
            const resourceType =
              resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
            gameMap[y][x] = resourceType;
          }
        }
      }

      function placeMonsters() {
        for (let i = 0; i < 12; i++) {
          const x = Math.floor(Math.random() * MAP_WIDTH);
          const y = Math.floor(Math.random() * MAP_HEIGHT);

          if (
            gameMap[y][x] === "GRASS" &&
            (Math.abs(x - gameState.hero.x) > 3 ||
              Math.abs(y - gameState.hero.y) > 3)
          ) {
            gameMap[y][x] = "MONSTER";
          }
        }
      }

      // ===========================================
      // –°–ò–°–¢–ï–ú–ê –ö–í–ï–°–¢–û–í
      // ===========================================

      function initializeQuests() {
        quests = [
          {
            id: "explorer",
            title: "–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å",
            description: "–û—Ç–∫—Ä–æ–π—Ç–µ 5 –Ω–æ–≤—ã—Ö –æ–±–ª–∞—Å—Ç–µ–π –∫–∞—Ä—Ç—ã",
            target: 5,
            current: 1,
            reward: { gold: 500 },
            completed: false,
          },
          {
            id: "treasure_hunter",
            title: "–°–±–æ—Ä—â–∏–∫ —Å–æ–∫—Ä–æ–≤–∏—â",
            description: "–ù–∞–π–¥–∏—Ç–µ 3 —Å—É–Ω–¥—É–∫–∞ —Å —Å–æ–∫—Ä–æ–≤–∏—â–∞–º–∏",
            target: 3,
            current: 0,
            reward: { crystals: 10 },
            completed: false,
          },
          {
            id: "monster_slayer",
            title: "–ò—Å—Ç—Ä–µ–±–∏—Ç–µ–ª—å –º–æ–Ω—Å—Ç—Ä–æ–≤",
            description: "–ü–æ–±–µ–¥–∏—Ç–µ 5 –º–æ–Ω—Å—Ç—Ä–æ–≤",
            target: 5,
            current: 0,
            reward: { experience: 1000 },
            completed: false,
          },
        ];
      }

      function checkQuests() {
        quests.forEach((quest) => {
          if (!quest.completed && quest.current >= quest.target) {
            quest.completed = true;
            giveQuestReward(quest);
            showNotification(`–ö–≤–µ—Å—Ç "${quest.title}" –∑–∞–≤–µ—Ä—à–µ–Ω!`);
            gameState.questsCompleted++;
          }
        });

        updateQuestsUI();
      }

      function giveQuestReward(quest) {
        Object.keys(quest.reward).forEach((resource) => {
          if (gameState.resources[resource] !== undefined) {
            gameState.resources[resource] += quest.reward[resource];
          } else if (resource === "experience") {
            gainExperience(quest.reward[resource]);
          }
        });
      }

      // ===========================================
      // –°–ò–°–¢–ï–ú–ê –û–ü–´–¢–ê –ò –£–†–û–í–ù–ï–ô
      // ===========================================

      function gainExperience(amount) {
        gameState.hero.experience += amount;
        const expNeeded = gameState.hero.level * 1000;

        if (gameState.hero.experience >= expNeeded) {
          levelUp();
        }
      }

      function levelUp() {
        gameState.hero.level++;
        gameState.hero.experience = 0;

        // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫
        gameState.hero.stats.attack += Math.floor(Math.random() * 3) + 1;
        gameState.hero.stats.defense += Math.floor(Math.random() * 3) + 1;
        gameState.hero.stats.magic += Math.floor(Math.random() * 2) + 1;
        gameState.hero.stats.knowledge += Math.floor(Math.random() * 2) + 1;

        showNotification(
          `–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –¥–æ—Å—Ç–∏–≥–ª–∏ ${gameState.hero.level} —É—Ä–æ–≤–Ω—è!`
        );
        updateUI();
      }

      // ===========================================
      // –¢–£–ú–ê–ù –í–û–ô–ù–´
      // ===========================================

      function revealArea(centerX, centerY, radius) {
        let newAreasExplored = 0;

        for (let x = centerX - radius; x <= centerX + radius; x++) {
          for (let y = centerY - radius; y <= centerY + radius; y++) {
            if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
              const distance = Math.sqrt(
                (x - centerX) ** 2 + (y - centerY) ** 2
              );
              if (distance <= radius && fogOfWar[y][x]) {
                fogOfWar[y][x] = false;
                exploredTiles.add(`${x},${y}`);
                newAreasExplored++;
              }
            }
          }
        }

        if (newAreasExplored > 0) {
          gameState.areasExplored += Math.floor(newAreasExplored / 5);
          updateQuest("explorer", Math.floor(newAreasExplored / 5));
        }
      }

      function updateQuest(questId, amount) {
        const quest = quests.find((q) => q.id === questId);
        if (quest && !quest.completed) {
          quest.current += amount;
          checkQuests();
        }
      }

      // ===========================================
      // –ü–û–ò–°–ö –ü–£–¢–ò (A*)
      // ===========================================

      function findPath(startX, startY, endX, endY) {
        const openSet = [];
        const closedSet = new Set();
        const cameFrom = new Map();
        const gScore = new Map();
        const fScore = new Map();

        const start = `${startX},${startY}`;
        const end = `${endX},${endY}`;

        openSet.push({ x: startX, y: startY, f: 0 });
        gScore.set(start, 0);
        fScore.set(start, heuristic(startX, startY, endX, endY));

        while (openSet.length > 0) {
          // –ù–∞–π—Ç–∏ —É–∑–µ–ª —Å –Ω–∞–∏–º–µ–Ω—å—à–∏–º fScore
          let current = openSet.reduce((min, node) =>
            fScore.get(`${node.x},${node.y}`) < fScore.get(`${min.x},${min.y}`)
              ? node
              : min
          );

          const currentKey = `${current.x},${current.y}`;

          if (currentKey === end) {
            return reconstructPath(cameFrom, currentKey);
          }

          openSet.splice(openSet.indexOf(current), 1);
          closedSet.add(currentKey);

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å–µ–¥–µ–π
          const neighbors = getNeighbors(current.x, current.y);

          for (const neighbor of neighbors) {
            const neighborKey = `${neighbor.x},${neighbor.y}`;

            if (closedSet.has(neighborKey)) continue;

            const tentativeGScore =
              gScore.get(currentKey) + getTileCost(neighbor.x, neighbor.y);

            if (!gScore.has(neighborKey)) {
              gScore.set(neighborKey, Infinity);
            }

            if (tentativeGScore < gScore.get(neighborKey)) {
              cameFrom.set(neighborKey, currentKey);
              gScore.set(neighborKey, tentativeGScore);
              fScore.set(
                neighborKey,
                tentativeGScore + heuristic(neighbor.x, neighbor.y, endX, endY)
              );

              if (
                !openSet.some(
                  (node) => node.x === neighbor.x && node.y === neighbor.y
                )
              ) {
                openSet.push(neighbor);
              }
            }
          }
        }

        return []; // –ü—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω
      }

      function heuristic(x1, y1, x2, y2) {
        return Math.abs(x1 - x2) + Math.abs(y1 - y2);
      }

      function getNeighbors(x, y) {
        const neighbors = [];
        const directions = [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1],
        ];

        for (const [dx, dy] of directions) {
          const newX = x + dx;
          const newY = y + dy;

          if (newX >= 0 && newX < MAP_WIDTH && newY >= 0 && newY < MAP_HEIGHT) {
            if (isPassable(newX, newY)) {
              neighbors.push({ x: newX, y: newY });
            }
          }
        }

        return neighbors;
      }

      function reconstructPath(cameFrom, current) {
        const path = [];
        while (cameFrom.has(current)) {
          const [x, y] = current.split(",").map(Number);
          path.unshift({ x, y });
          current = cameFrom.get(current);
        }
        return path;
      }

      function isPassable(x, y) {
        if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return false;
        return TILE_TYPES[gameMap[y][x]].passable;
      }

      function getTileCost(x, y) {
        if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return 999;
        return TILE_TYPES[gameMap[y][x]].cost;
      }

      // ===========================================
      // –û–ë–†–ê–ë–û–¢–ö–ê –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–ô
      // ===========================================

      function handleTileInteraction(x, y) {
        const tileType = gameMap[y][x];

        switch (tileType) {
          case "TREASURE":
            const goldFound = Math.floor(Math.random() * 500) + 200;
            gameState.resources.gold += goldFound;
            gameMap[y][x] = "GRASS";
            showNotification(`–ù–∞–π–¥–µ–Ω–æ —Å–æ–∫—Ä–æ–≤–∏—â–µ: +${goldFound} –∑–æ–ª–æ—Ç–∞!`);
            gameState.treasuresFound++;
            updateQuest("treasure_hunter", 1);
            break;

          case "RESOURCE_GOLD":
            const gold = Math.floor(Math.random() * 200) + 100;
            gameState.resources.gold += gold;
            gameMap[y][x] = "GRASS";
            showNotification(`–î–æ–±—ã—Ç–æ –∑–æ–ª–æ—Ç–æ: +${gold}`);
            break;

          case "RESOURCE_STONE":
            const stone = Math.floor(Math.random() * 10) + 5;
            gameState.resources.stone += stone;
            gameMap[y][x] = "GRASS";
            showNotification(`–î–æ–±—ã—Ç –∫–∞–º–µ–Ω—å: +${stone}`);
            break;

          case "RESOURCE_WOOD":
            const wood = Math.floor(Math.random() * 15) + 10;
            gameState.resources.wood += wood;
            gameMap[y][x] = "GRASS";
            showNotification(`–°—Ä—É–±–ª–µ–Ω–æ –¥–µ—Ä–µ–≤–æ: +${wood}`);
            break;

          case "MONSTER":
            showDialog(
              "–í—Å—Ç—Ä–µ—á–∞ —Å –º–æ–Ω—Å—Ç—Ä–æ–º!",
              "–ü–µ—Ä–µ–¥ –≤–∞–º–∏ —Å—Ç–æ–∏—Ç —Å–≤–∏—Ä–µ–ø—ã–π –º–æ–Ω—Å—Ç—Ä. –•–æ—Ç–∏—Ç–µ —Å—Ä–∞–∑–∏—Ç—å—Å—è?",
              () => fightMonster(x, y),
              () => showNotification("–í—ã —Ä–µ—à–∏–ª–∏ –∏–∑–±–µ–∂–∞—Ç—å –±–∏—Ç–≤—ã.")
            );
            break;

          case "TOWN":
            showDialog(
              "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –≥–æ—Ä–æ–¥!",
              "–ó–¥–µ—Å—å –≤—ã –º–æ–∂–µ—Ç–µ –æ—Ç–¥–æ—Ö–Ω—É—Ç—å –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—á–∫–∏ –¥–≤–∏–∂–µ–Ω–∏—è.",
              () => visitTown(),
              () => showNotification("–í—ã –ø–æ–∫–∏–Ω—É–ª–∏ –≥–æ—Ä–æ–¥.")
            );
            break;
        }
      }

      function fightMonster(x, y) {
        const victory = Math.random() > 0.3; // 70% —à–∞–Ω—Å –ø–æ–±–µ–¥—ã

        if (victory) {
          const expGained = Math.floor(Math.random() * 300) + 100;
          const goldGained = Math.floor(Math.random() * 150) + 50;

          gameState.resources.gold += goldGained;
          gainExperience(expGained);
          gameMap[y][x] = "GRASS";

          showNotification(
            `–ú–æ–Ω—Å—Ç—Ä –ø–æ–±–µ–∂–¥–µ–Ω! +${expGained} –æ–ø—ã—Ç–∞, +${goldGained} –∑–æ–ª–æ—Ç–∞`
          );
          updateQuest("monster_slayer", 1);
        } else {
          gameState.hero.actionPoints = Math.max(
            10,
            gameState.hero.actionPoints - 30
          );
          showNotification("–ú–æ–Ω—Å—Ç—Ä —Ä–∞–Ω–∏–ª –≤–∞—Å! -30 –æ—á–∫–æ–≤ –¥–≤–∏–∂–µ–Ω–∏—è");
        }

        closeDialog();
      }

      function visitTown() {
        gameState.hero.actionPoints = gameState.hero.maxActionPoints;
        const healingCost = 100;

        if (gameState.resources.gold >= healingCost) {
          gameState.resources.gold -= healingCost;
          showNotification(
            `–û—Ç–¥—ã—Ö –≤ –≥–æ—Ä–æ–¥–µ: –æ—á–∫–∏ –¥–≤–∏–∂–µ–Ω–∏—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã (-${healingCost} –∑–æ–ª–æ—Ç–∞)`
          );
        } else {
          showNotification("–û—á–∫–∏ –¥–≤–∏–∂–µ–Ω–∏—è —á–∞—Å—Ç–∏—á–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã");
        }

        closeDialog();
      }

      // ===========================================
      // –î–í–ò–ñ–ï–ù–ò–ï –ì–ï–†–û–Ø
      // ===========================================

      function moveHero(targetX, targetY) {
        if (!isPassable(targetX, targetY)) {
          showNotification("–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø—Ä–æ–π—Ç–∏ –≤ —ç—Ç—É –æ–±–ª–∞—Å—Ç—å!");
          return false;
        }

        const path = findPath(
          gameState.hero.x,
          gameState.hero.y,
          targetX,
          targetY
        );

        if (path.length === 0) {
          showNotification("–ü—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω!");
          return false;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Ö–≤–∞—Ç–∞–µ—Ç –ª–∏ –æ—á–∫–æ–≤ –¥–≤–∏–∂–µ–Ω–∏—è
        const totalCost = calculatePathCost(path);
        if (totalCost > gameState.hero.actionPoints) {
          showNotification("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ—á–∫–æ–≤ –¥–≤–∏–∂–µ–Ω–∏—è!");
          return false;
        }

        // –í—ã–ø–æ–ª–Ω—è–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ
        pathToTarget = path;
        executeMovement();
        return true;
      }

      function calculatePathCost(path) {
        let cost = 0;
        for (const point of path) {
          cost += getTileCost(point.x, point.y) * 10; // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º —Å—Ç–æ–∏–º–æ—Å—Ç—å
        }
        return cost;
      }

      function executeMovement() {
        if (pathToTarget.length === 0) return;

        const nextStep = pathToTarget.shift();
        const cost = getTileCost(nextStep.x, nextStep.y) * 10;

        gameState.hero.x = nextStep.x;
        gameState.hero.y = nextStep.y;
        gameState.hero.actionPoints -= cost;

        // –û—Ç–∫—Ä—ã–≤–∞–µ–º –Ω–æ–≤—ã–µ –æ–±–ª–∞—Å—Ç–∏
        revealArea(gameState.hero.x, gameState.hero.y, 1);

        // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–º–µ—Ä—É
        updateCamera();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å —Ç–∞–π–ª–æ–º
        handleTileInteraction(gameState.hero.x, gameState.hero.y);

        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
        if (pathToTarget.length > 0) {
          setTimeout(executeMovement, 200);
        }

        updateUI();
      }

      function updateCamera() {
        gameState.camera.x = Math.max(
          0,
          Math.min(
            gameState.hero.x - Math.floor(VIEWPORT_TILES_X / 2),
            MAP_WIDTH - VIEWPORT_TILES_X
          )
        );

        gameState.camera.y = Math.max(
          0,
          Math.min(
            gameState.hero.y - Math.floor(VIEWPORT_TILES_Y / 2),
            MAP_HEIGHT - VIEWPORT_TILES_Y
          )
        );
      }

      // ===========================================
      // –û–¢–†–ò–°–û–í–ö–ê
      // ===========================================

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // –†–∏—Å—É–µ–º –∫–∞—Ä—Ç—É
        for (let y = 0; y < VIEWPORT_TILES_Y; y++) {
          for (let x = 0; x < VIEWPORT_TILES_X; x++) {
            const mapX = x + gameState.camera.x;
            const mapY = y + gameState.camera.y;

            if (
              mapX >= 0 &&
              mapX < MAP_WIDTH &&
              mapY >= 0 &&
              mapY < MAP_HEIGHT
            ) {
              drawTile(x * TILE_SIZE, y * TILE_SIZE, mapX, mapY);
            }
          }
        }

        // –†–∏—Å—É–µ–º –ø—É—Ç—å –∫ —Ü–µ–ª–∏
        drawPath();

        // –†–∏—Å—É–µ–º –≥–µ—Ä–æ—è
        drawHero();

        // –†–∏—Å—É–µ–º —Ç—É–º–∞–Ω –≤–æ–π–Ω—ã
        if (gameState.showFogOfWar) {
          drawFogOfWar();
        }
      }

      function drawTile(screenX, screenY, mapX, mapY) {
        const tileType = TILE_TYPES[gameMap[mapY][mapX]];
        const isExplored = !fogOfWar[mapY][mapX];

        // –ë–∞–∑–æ–≤—ã–π —Ü–≤–µ—Ç —Ç–∞–π–ª–∞
        ctx.fillStyle = isExplored ? tileType.color : "#333333";
        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);

        // –ì—Ä–∞–Ω–∏—Ü—ã —Ç–∞–π–ª–∞
        ctx.strokeStyle = isExplored
          ? "rgba(0,0,0,0.1)"
          : "rgba(255,255,255,0.05)";
        ctx.strokeRect(screenX, screenY, TILE_SIZE, TILE_SIZE);

        // –≠–º–æ–¥–∑–∏ –¥–ª—è –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–Ω—ã—Ö —Ç–∞–π–ª–æ–≤
        if (isExplored) {
          ctx.font = `${TILE_SIZE * 0.6}px Arial`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(
            tileType.emoji,
            screenX + TILE_SIZE / 2,
            screenY + TILE_SIZE / 2
          );
        }

        // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –¥–ª—è —Ä–µ—Å—É—Ä—Å–æ–≤
        if (
          isExplored &&
          (gameMap[mapY][mapX].includes("RESOURCE") ||
            gameMap[mapY][mapX] === "TREASURE")
        ) {
          const time = Date.now() / 500;
          const alpha = Math.sin(time + mapX + mapY) * 0.3 + 0.7;
          ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
          ctx.fillRect(screenX + 2, screenY + 2, TILE_SIZE - 4, TILE_SIZE - 4);
        }
      }

      function drawHero() {
        const screenX = (gameState.hero.x - gameState.camera.x) * TILE_SIZE;
        const screenY = (gameState.hero.y - gameState.camera.y) * TILE_SIZE;

        // –¢–µ–Ω—å –≥–µ—Ä–æ—è
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(screenX + 5, screenY + 5, TILE_SIZE - 10, TILE_SIZE - 10);

        // –ì–µ—Ä–æ–π
        ctx.fillStyle = "#E74C3C";
        ctx.fillRect(screenX + 2, screenY + 2, TILE_SIZE - 4, TILE_SIZE - 4);

        // –≠–º–æ–¥–∑–∏ –≥–µ—Ä–æ—è
        ctx.font = `${TILE_SIZE * 0.8}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("üõ°Ô∏è", screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2);

        // –ê–Ω–∏–º–∞—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è
        const time = Date.now() / 200;
        const bounce = Math.sin(time) * 2;
        ctx.translate(0, bounce);
        ctx.translate(0, -bounce);
      }

      function drawPath() {
        if (pathToTarget.length === 0) return;

        ctx.strokeStyle = "rgba(52, 152, 219, 0.8)";
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);

        ctx.beginPath();
        let startX =
          (gameState.hero.x - gameState.camera.x) * TILE_SIZE + TILE_SIZE / 2;
        let startY =
          (gameState.hero.y - gameState.camera.y) * TILE_SIZE + TILE_SIZE / 2;
        ctx.moveTo(startX, startY);

        pathToTarget.forEach((point) => {
          const x = (point.x - gameState.camera.x) * TILE_SIZE + TILE_SIZE / 2;
          const y = (point.y - gameState.camera.y) * TILE_SIZE + TILE_SIZE / 2;
          ctx.lineTo(x, y);
        });

        ctx.stroke();
        ctx.setLineDash([]);
      }

      function drawFogOfWar() {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";

        for (let y = 0; y < VIEWPORT_TILES_Y; y++) {
          for (let x = 0; x < VIEWPORT_TILES_X; x++) {
            const mapX = x + gameState.camera.x;
            const mapY = y + gameState.camera.y;

            if (
              mapX >= 0 &&
              mapX < MAP_WIDTH &&
              mapY >= 0 &&
              mapY < MAP_HEIGHT
            ) {
              if (fogOfWar[mapY][mapX]) {
                ctx.fillRect(
                  x * TILE_SIZE,
                  y * TILE_SIZE,
                  TILE_SIZE,
                  TILE_SIZE
                );
              }
            }
          }
        }
      }

      // ===========================================
      // –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò–ù–¢–ï–†–§–ï–ô–°–û–ú
      // ===========================================

      function updateUI() {
        document.getElementById("heroName").textContent = `–°—ç—Ä –ö–æ–¥–µ—Ä—É—Å`;
        document.getElementById(
          "heroLevel"
        ).textContent = `–£—Ä–æ–≤–µ–Ω—å ${gameState.hero.level}`;
        document.getElementById("heroAttack").textContent =
          gameState.hero.stats.attack;
        document.getElementById("heroDefense").textContent =
          gameState.hero.stats.defense;
        document.getElementById("heroMagic").textContent =
          gameState.hero.stats.magic;
        document.getElementById("heroKnowledge").textContent =
          gameState.hero.stats.knowledge;

        document.getElementById(
          "actionPoints"
        ).textContent = `${gameState.hero.actionPoints}/${gameState.hero.maxActionPoints}`;

        document.getElementById("gold").textContent = gameState.resources.gold;
        document.getElementById("stone").textContent =
          gameState.resources.stone;
        document.getElementById("wood").textContent = gameState.resources.wood;
        document.getElementById("crystals").textContent =
          gameState.resources.crystals;
      }

      function updateQuestsUI() {
        const questsList = document.getElementById("questsList");
        questsList.innerHTML = "";

        quests.forEach((quest) => {
          const questDiv = document.createElement("div");
          questDiv.className = "quest-item";
          if (quest.completed) questDiv.style.opacity = "0.6";

          questDiv.innerHTML = `
                    <div class="quest-title">${quest.title} ${
            quest.completed ? "‚úÖ" : ""
          }</div>
                    <div class="quest-description">${quest.description}</div>
                    <div class="quest-description">–ü—Ä–æ–≥—Ä–µ—Å—Å: ${quest.current}/${
            quest.target
          }</div>
                    <div class="quest-reward">–ù–∞–≥—Ä–∞–¥–∞: ${Object.keys(
                      quest.reward
                    )
                      .map((key) => `${quest.reward[key]} ${key}`)
                      .join(", ")}</div>
                `;

          questsList.appendChild(questDiv);
        });
      }

      function showNotification(text) {
        const notification = document.getElementById("notification");
        notification.textContent = text;
        notification.style.display = "block";
        notification.style.animation = "none";

        setTimeout(() => {
          notification.style.animation = "slideInOut 3s ease-in-out forwards";
        }, 10);

        setTimeout(() => {
          notification.style.display = "none";
        }, 3000);
      }

      function showDialog(title, text, acceptCallback, declineCallback) {
        document.getElementById("dialogTitle").textContent = title;
        document.getElementById("dialogText").textContent = text;
        document.getElementById("dialog").style.display = "block";

        document.getElementById("dialogAccept").onclick = acceptCallback;
        document.getElementById("dialogDecline").onclick = declineCallback;
      }

      function closeDialog() {
        document.getElementById("dialog").style.display = "none";
      }

      // ===========================================
      // –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô
      // ===========================================

      canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const x =
          Math.floor((e.clientX - rect.left) / TILE_SIZE) + gameState.camera.x;
        const y =
          Math.floor((e.clientY - rect.top) / TILE_SIZE) + gameState.camera.y;

        if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
          if (gameState.hero.actionPoints > 0) {
            moveHero(x, y);
          } else {
            showNotification("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ—á–∫–æ–≤ –¥–≤–∏–∂–µ–Ω–∏—è! –ó–∞–≤–µ—Ä—à–∏—Ç–µ —Ö–æ–¥.");
          }
        }
      });

      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x =
          Math.floor((e.clientX - rect.left) / TILE_SIZE) + gameState.camera.x;
        const y =
          Math.floor((e.clientY - rect.top) / TILE_SIZE) + gameState.camera.y;

        if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
          const tileType = gameMap[y][x];
          const tile = TILE_TYPES[tileType];
          showNotification(
            `${tile.emoji} ${tileType} (–°—Ç–æ–∏–º–æ—Å—Ç—å: ${tile.cost})`
          );
        }
      });

      document.addEventListener("keydown", (e) => {
        switch (e.code) {
          case "Space":
            e.preventDefault();
            nextTurn();
            break;
          case "KeyM":
            gameState.showFogOfWar = !gameState.showFogOfWar;
            showNotification(
              `–¢—É–º–∞–Ω –≤–æ–π–Ω—ã: ${gameState.showFogOfWar ? "–í–∫–ª—é—á–µ–Ω" : "–û—Ç–∫–ª—é—á–µ–Ω"}`
            );
            break;
          case "KeyQ":
            updateQuestsUI();
            showNotification("–°–ø–∏—Å–æ–∫ –∫–≤–µ—Å—Ç–æ–≤ –æ–±–Ω–æ–≤–ª–µ–Ω");
            break;
          case "KeyS":
            const shopPanel = document.querySelector(".shop-panel");
            if (shopPanel) {
              shopPanel.style.display =
                shopPanel.style.display === "none" ? "block" : "none";
              showNotification(
                "–ú–∞–≥–∞–∑–∏–Ω " +
                  (shopPanel.style.display === "none" ? "—Å–∫—Ä—ã—Ç" : "–æ—Ç–∫—Ä—ã—Ç")
              );
            }
            break;
        }
      });

      // ===========================================
      // –ò–ì–†–û–í–û–ô –¶–ò–ö–õ
      // ===========================================

      function nextTurn() {
        gameState.turnNumber++;
        gameState.hero.actionPoints = gameState.hero.maxActionPoints;

        // –°–ª—É—á–∞–π–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è
        if (Math.random() < 0.1) {
          randomEvent();
        }

        showNotification(`–•–æ–¥ ${gameState.turnNumber} –Ω–∞—á–∞–ª—Å—è!`);
        updateUI();
      }

      function randomEvent() {
        const events = [
          () => {
            const gold = Math.floor(Math.random() * 100) + 50;
            gameState.resources.gold += gold;
            showNotification(`–¢–æ—Ä–≥–æ–≤—Ü—ã –¥–∞–ª–∏ –≤–∞–º ${gold} –∑–æ–ª–æ—Ç–∞!`);
          },
          () => {
            gameState.hero.actionPoints += 50;
            showNotification(
              "–í—ã –Ω–∞—à–ª–∏ –ª–æ—à–∞–¥—å! +50 –æ—á–∫–æ–≤ –¥–≤–∏–∂–µ–Ω–∏—è –Ω–∞ —ç—Ç–æ—Ç —Ö–æ–¥."
            );
          },
          () => {
            const crystals = Math.floor(Math.random() * 3) + 1;
            gameState.resources.crystals += crystals;
            showNotification(`–ù–∞–π–¥–µ–Ω—ã –º–∞–≥–∏—á–µ—Å–∫–∏–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã: +${crystals}!`);
          },
        ];

        const event = events[Math.floor(Math.random() * events.length)];
        event();
      }

      function gameLoop() {
        render();
        requestAnimationFrame(gameLoop);
      }

      // ===========================================
      // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò–ì–†–´
      // ===========================================

      function initGame() {
        const loadingSteps = [
          { text: "Generating world...", duration: 1000 },
          { text: "Placing resources...", duration: 800 },
          { text: "Creating quests...", duration: 600 },
          { text: "Initializing hero...", duration: 400 },
          { text: "Ready to explore!", duration: 200 },
        ];

        let currentStep = 0;
        const loadingBar = document.getElementById("loadingBar");
        const loadingText = document.getElementById("loadingText");

        function nextLoadingStep() {
          if (currentStep < loadingSteps.length) {
            const step = loadingSteps[currentStep];
            loadingText.textContent = step.text;
            loadingBar.style.width =
              ((currentStep + 1) / loadingSteps.length) * 100 + "%";

            setTimeout(() => {
              currentStep++;
              nextLoadingStep();
            }, step.duration);
          } else {
            // –ò–≥—Ä–∞ –≥–æ—Ç–æ–≤–∞
            generateMap();
            initializeQuests();
            updateCamera();
            updateUI();
            updateQuestsUI();

            setTimeout(() => {
              document.getElementById("loadingScreen").style.display = "none";
              document.getElementById("gameInterface").style.display = "flex";
              gameLoop();

              // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –º–∞–≥–∞–∑–∏–Ω–∞
              if (typeof updateShopDisplay === "function") {
                updateShopDisplay();
              }

              showNotification(
                "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Heroes Adventure! –ù–∞–∂–º–∏—Ç–µ S –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –º–∞–≥–∞–∑–∏–Ω–∞"
              );
            }, 500);
          }
        }

        nextLoadingStep();
      }

      // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
      initGame();

      // ===========================================
      // –û–ë–†–ê–ó–û–í–ê–¢–ï–õ–¨–ù–´–ï –ö–û–ú–ú–ï–ù–¢–ê–†–ò–ò
      // ===========================================

      /*
        –û–ë–†–ê–ó–û–í–ê–¢–ï–õ–¨–ù–´–ï –ö–û–ù–¶–ï–ü–¶–ò–ò –í –≠–¢–û–ô –ò–ì–†–ï:
        
        1. –¢–ê–ô–õ–û–í–´–ï –ö–ê–†–¢–´ –ò –î–í–£–ú–ï–†–ù–´–ï –ú–ê–°–°–ò–í–´
           - –ü—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –º–∏—Ä–∞ –≤ –≤–∏–¥–µ —Å–µ—Ç–∫–∏
           - –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å 2D –º–∞—Å—Å–∏–≤–∞–º–∏
           - –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω—ã–µ —Å–∏—Å—Ç–µ–º—ã –∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
        
        2. –ê–õ–ì–û–†–ò–¢–ú –ü–û–ò–°–ö–ê –ü–£–¢–ò A*
           - –û–¥–∏–Ω –∏–∑ –≤–∞–∂–Ω–µ–π—à–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –≤ –∏–≥—Ä–∞—Ö
           - –≠–≤—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
           - –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö: –æ—Ç–∫—Ä—ã—Ç—ã–π –∏ –∑–∞–∫—Ä—ã—Ç—ã–π —Å–ø–∏—Å–æ–∫
        
        3. –¢–£–ú–ê–ù –í–û–ô–ù–´ (FOG OF WAR)
           - –°–∏—Å—Ç–µ–º–∞ —Å–∫—Ä—ã—Ç–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
           - –ê–ª–≥–æ—Ä–∏—Ç–º—ã –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –æ—Ç–∫—Ä—ã—Ç–∏—è –∫–∞—Ä—Ç—ã
           - –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
        
        4. –ü–†–û–¶–ï–î–£–†–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø –ö–û–ù–¢–ï–ù–¢–ê
           - –ê–ª–≥–æ—Ä–∏—Ç–º—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–∞—Ä—Ç
           - –†–∞–∑–º–µ—â–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º
           - –°–∏—Å—Ç–µ–º—ã —Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏ –∏ seed
        
        5. –°–ò–°–¢–ï–ú–ê –ö–í–ï–°–¢–û–í –ò –î–û–°–¢–ò–ñ–ï–ù–ò–ô
           - –ü–∞—Ç—Ç–µ—Ä–Ω Observer –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏–π
           - –°–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –∏ –Ω–∞–≥—Ä–∞–¥
           - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è–º–∏ –∫–≤–µ—Å—Ç–æ–≤
        
        6. –ö–ê–ú–ï–†–ê –ò VIEWPORT
           - –í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã vs —ç–∫—Ä–∞–Ω–Ω—ã–µ
           - –°–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∑–∞ –∏–≥—Ä–æ–∫–æ–º
           - –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –≤–∏–¥–∏–º–æ–π –æ–±–ª–∞—Å—Ç–∏
        
        7. –ò–ì–†–û–í–û–ô –ò–ò –ò –°–¢–†–ê–¢–ï–ì–ò–ò
           - –ü—Ä–æ—Å—Ç–æ–π –ò–ò –¥–ª—è —Å–ª—É—á–∞–π–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π
           - –°–∏—Å—Ç–µ–º—ã –±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤
           - –ê–ª–≥–æ—Ä–∏—Ç–º—ã –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π
        
        8. –ê–†–•–ò–¢–ï–ö–¢–£–†–ê –°–õ–û–ñ–ù–´–• –ò–ì–†
           - –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –ª–æ–≥–∏–∫–∏ –∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è
           - –°–∏—Å—Ç–µ–º–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π –∏–≥—Ä—ã
           - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–ª–æ–∂–Ω–æ—Å—Ç—å—é –∫–æ–¥–∞
        
        –ê–õ–ì–û–†–ò–¢–ú–´:
        - A* –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫—Ä–∞—Ç—á–∞–π—à–µ–≥–æ –ø—É—Ç–∏
        - –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å –ø–æ–º–æ—â—å—é —à—É–º–∞
        - Flood fill –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –æ–±–ª–∞—Å—Ç–µ–π —Ç—É–º–∞–Ω–∞ –≤–æ–π–Ω—ã
        - –°–∏—Å—Ç–µ–º–∞ —Å–æ–±—ã—Ç–∏–π –¥–ª—è —Å–≤—è–∑–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        - Spatial partitioning –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø–æ–∏—Å–∫–∞
        */

      // ===========================================
      // –°–ò–°–¢–ï–ú–ê –ú–ê–ì–ê–ó–ò–ù–ê (—Ñ–∏–Ω–∞–ª—å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è)
      // ===========================================

      const SHOP_ITEMS = {
        buildings: [
          {
            id: "watchtower",
            name: "üóº –ë–∞—à–Ω—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è",
            description: "–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Ä–∞–¥–∏—É—Å –æ–±–∑–æ—Ä–∞ –Ω–∞ +2 —Ç–∞–π–ª–∞",
            cost: { stone: 5, wood: 3, gold: 200 },
          },
          {
            id: "mine",
            name: "‚õèÔ∏è –®–∞—Ö—Ç–∞",
            description: "–ü—Ä–∏–Ω–æ—Å–∏—Ç +5 –∫–∞–º–Ω—è –∫–∞–∂–¥—ã–π —Ö–æ–¥",
            cost: { wood: 10, gold: 300 },
          },
        ],
        equipment: [
          {
            id: "iron_sword",
            name: "‚öîÔ∏è –ñ–µ–ª–µ–∑–Ω—ã–π –º–µ—á",
            description: "–ê—Ç–∞–∫–∞ +5",
            cost: { gold: 300, stone: 2 },
          },
          {
            id: "steel_armor",
            name: "üõ°Ô∏è –°—Ç–∞–ª—å–Ω–∞—è –±—Ä–æ–Ω—è",
            description: "–ó–∞—â–∏—Ç–∞ +8",
            cost: { gold: 500, stone: 5 },
          },
        ],
        magic: [
          {
            id: "reveal_map",
            name: "üîç –í–∏–¥–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã",
            description: "–û—Ç–∫—Ä—ã–≤–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å –∫–∞—Ä—Ç—ã",
            cost: { crystals: 2, gold: 150 },
          },
          {
            id: "teleport",
            name: "‚ú® –¢–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏—è",
            description: "–ü–µ—Ä–µ—Ö–æ–¥ –∫ –≥–æ—Ä–æ–¥—É",
            cost: { crystals: 3, gold: 100 },
          },
        ],
        army: [
          {
            id: "warrior",
            name: "‚öîÔ∏è –í–æ–∏–Ω",
            description: "–î–∞–µ—Ç +2 –∫ –∞—Ç–∞–∫–µ",
            cost: { gold: 100, wood: 2 },
          },
          {
            id: "archer",
            name: "üèπ –õ—É—á–Ω–∏–∫",
            description: "–£–º–µ–Ω—å—à–∞–µ—Ç —É—Ä–æ–Ω –Ω–∞ 10%",
            cost: { gold: 150, wood: 5 },
          },
        ],
      };

      function switchShopTab(tab) {
        gameState.currentShopTab = tab;
        updateShopDisplay();
      }

      function updateShopDisplay() {
        const content = document.getElementById("shopContent");
        if (!content) return;

        const items = SHOP_ITEMS[gameState.currentShopTab] || [];
        content.innerHTML = "";

        items.forEach((item) => {
          const itemDiv = document.createElement("div");
          itemDiv.className = "shop-item";

          const canAfford = checkResourceCost(item.cost);
          const costText = Object.keys(item.cost)
            .map((resource) => {
              const cost = item.cost[resource];
              const current = gameState.resources[resource] || 0;
              const enough = current >= cost;
              const icon =
                resource === "gold"
                  ? "üí∞"
                  : resource === "stone"
                  ? "ü™®"
                  : resource === "wood"
                  ? "üå≥"
                  : "‚ö°";
              return `<span style="color: ${
                enough ? "#27AE60" : "#E74C3C"
              }">${icon}${cost}</span>`;
            })
            .join(" ");

          itemDiv.innerHTML = `
                    <div class="shop-item-name">${item.name}</div>
                    <div class="shop-item-description">${item.description}</div>
                    <div class="shop-item-cost">
                        <div class="cost-display">–°—Ç–æ–∏–º–æ—Å—Ç—å: ${costText}</div>
                        <button class="shop-buy-btn" ${
                          !canAfford ? "disabled" : ""
                        } 
                                onclick="buyItem('${
                                  gameState.currentShopTab
                                }', '${item.id}')">–ö—É–ø–∏—Ç—å</button>
                    </div>
                `;

          content.appendChild(itemDiv);
        });
      }

      function checkResourceCost(cost) {
        return Object.keys(cost).every((resource) => {
          return (gameState.resources[resource] || 0) >= cost[resource];
        });
      }

      function payResourceCost(cost) {
        Object.keys(cost).forEach((resource) => {
          gameState.resources[resource] =
            (gameState.resources[resource] || 0) - cost[resource];
        });
      }

      function buyItem(category, itemId) {
        const item = SHOP_ITEMS[category].find((i) => i.id === itemId);
        if (!item || !checkResourceCost(item.cost)) return;

        payResourceCost(item.cost);
        showNotification(`–ö—É–ø–ª–µ–Ω–æ: ${item.name}`);
        updateUI();
        updateShopDisplay();
      }
    </script>
  </body>
</html>
